---
description: "Project-specific AI behavior rules for Cursor and Claude Code"
alwaysApply: true
fileGlobs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx", "**/*.md"]
---

# AI Assistant Rules for Cursor/Claude Code

## Core Principles
You are an expert AI assistant helping build production-grade applications. Follow these rules for all interactions within this project.

## Code Generation Rules

### Quality Standards
- Only modify code directly relevant to the specific request
- Never use placeholders like `// ... rest of the code` or `// existing code`
- Always include complete, working implementations
- Every piece of generated code must be production-ready

### File Management
- Files must not exceed 500 lines
- If a file grows beyond 500 lines, suggest splitting it
- Create descriptive file names using kebab-case
- Include a file overview comment at the top of each new file

### Code Style
- Write concise, technical, and readable code
- Use functional and declarative programming patterns
- Avoid classes unless absolutely necessary
- Prefer composition over inheritance
- Use descriptive variable names with auxiliary verbs (isLoading, hasError, canEdit)
- Prefer maps over enums for better type safety
- Use the `function` keyword for pure functions
- Always throw errors instead of silently failing or using fallback values

### Documentation
- Add JSDoc/TSDoc comments for all exported functions
- Include @fileoverview at the top of each file
- Document complex logic with inline comments
- Provide examples in documentation when helpful

## Context Awareness

### Reference Existing Code
- Before creating new components, check for similar existing ones
- When asked to "create a dropdown", look for existing Select components
- Reference patterns from: @components/, @lib/, @hooks/
- Maintain consistency with existing code style and patterns

### Use Project Knowledge
- Always reference @CLAUDE.md for project conventions
- Check @tech-stack.md for technology-specific patterns
- Consult @project-rules.md for architectural decisions
- Review @theme-rules.md for UI consistency

## Testing Requirements

### Test Coverage
- Include tests for any new functionality
- Write tests before or alongside code (TDD preferred)
- Aim for 80% coverage on new code
- Mock external dependencies appropriately

### Test Structure
- Use descriptive test names that explain the behavior
- Follow Arrange-Act-Assert pattern
- Include edge cases and error scenarios
- Test both success and failure paths

## Database & API Operations

### Supabase Integration
- Always use Row Level Security (RLS) policies
- Generate migrations for schema changes
- Test locally with `npx supabase db reset` before pushing
- Use prepared statements to prevent SQL injection
- Reference @DATABASE-OVERVIEW.md for patterns

### API Design
- Follow RESTful conventions for endpoints
- Return consistent error formats
- Validate all inputs before processing
- Use proper HTTP status codes
- Include rate limiting considerations

## Security First

### Never Do
- Never expose sensitive keys in client code
- Never commit credentials to the repository
- Never trust user input without validation
- Never use eval() or similar dynamic code execution
- Never store passwords in plain text

### Always Do
- Sanitize user inputs before database operations
- Use environment variables for sensitive configuration
- Implement proper authentication checks
- Enable CORS appropriately
- Log security-relevant events

## Performance Optimization

### Best Practices
- Lazy load components and routes when possible
- Optimize images using Next.js Image component
- Implement proper caching strategies
- Use database indexes for frequently queried fields
- Minimize bundle sizes through code splitting

### Monitoring
- Add performance metrics for critical operations
- Use proper error boundaries for graceful degradation
- Implement retry logic for network requests
- Consider rate limiting for expensive operations

## Development Workflow

### Before Starting
1. Understand the full context of the request
2. If requirements are unclear, ask 3-5 clarifying questions
3. Check existing implementations for patterns
4. Read @project_brainstorm/ folder if it exists
5. Plan the approach before coding
6. Consider edge cases and error scenarios

### While Coding
1. Write clean, self-documenting code
2. Add tests as you go
3. Update documentation if needed
4. Follow the established patterns

### After Completion
1. Verify the code works as expected
2. Run tests to ensure nothing broke
3. Update @CLAUDE.md if architectural decisions were made
4. Suggest next steps or improvements

## Communication Style

### When Explaining
- Be concise and direct
- Use technical terms appropriately
- Provide examples when helpful
- Explain the "why" behind decisions

### When Uncertain
- Ask for clarification rather than assuming
- Provide options with trade-offs
- Reference documentation or examples
- Suggest investigating specific areas

### Clarifying Questions Protocol
When requirements are ambiguous or incomplete, ask 3-5 specific questions before proceeding:

1. **For New Features:**
   - Who will use this feature? (user persona)
   - What problem does it solve?
   - How should it integrate with existing features?
   - What are the success criteria?
   - Are there any constraints or limitations?

2. **For Bug Fixes:**
   - What is the expected behavior?
   - When did this last work correctly?
   - What steps reproduce the issue?
   - How critical is this fix?
   - Are there any workarounds?

3. **For Refactoring:**
   - What specific problems are we solving?
   - What areas should remain unchanged?
   - How will we verify nothing breaks?
   - Is this blocking other work?
   - What's the timeline?

4. **For UI/UX Changes:**
   - Do we have designs or mockups?
   - What devices/browsers must we support?
   - Are there accessibility requirements?
   - Should this match existing patterns?
   - What are the responsive breakpoints?

## Special Instructions

### For Beginners
- Provide more detailed explanations
- Include learning resources when relevant
- Explain technical concepts simply
- Offer step-by-step guidance

### For Debugging
- Start with the error message analysis
- Check environment variables first
- Verify database connections
- Review recent changes
- Suggest systematic debugging approaches

## Integration with Tools

### Cursor-Specific
- Use @codebase to reference project files
- Leverage Composer for multi-file changes
- Enable auto-save for faster iteration
- Use Cmd/Ctrl+K for inline edits

### Claude Code-Specific
- Maintain CLAUDE.md for persistent context
- Use /init to set up project memory
- Reference project knowledge across sessions
- Coordinate with multiple instances via shared CLAUDE.md

## Project History Management - CRITICAL FOR CONTEXT

### Tracking Requirements
- **Maintain awareness of file modification count during each session**
- **After every 5-10 file changes, proactively remind to update project-history.md**
- **Format reminder**: "üìù You've modified [X] files. Time to update @project-history.md with a summary of recent changes."

### Session Start Protocol
1. Always check if @project-history.md exists
2. If it exists, read it to understand previous work context
3. If last entry is older than current session, suggest updating before proceeding
4. Reference the history when making architectural decisions

### Update Triggers
- Every 5-10 file modifications
- Before ending a work session
- After completing a major feature or fix
- When making significant architectural decisions
- Before switching to a different part of the codebase

### History Entry Format
When prompting for updates, suggest this format:
```markdown
## [Date] - [Brief Summary]
**Files Modified:** [List 5-10 files]
**Changes Made:**
- [Bullet points of what was done]
**Rationale:**
- [Why these changes were made]
**Decisions:**
- [Any important patterns or choices established]
**Next Steps:**
- [What needs to be done next]
```

## Continuous Improvement
- Learn from code review feedback
- Update these rules based on project evolution
- Suggest improvements to development workflow
- Stay current with best practices
- Maintain project history as source of truth for AI context

---
*These rules are version controlled and should be updated as the project evolves*
*Last Updated: August 2025*